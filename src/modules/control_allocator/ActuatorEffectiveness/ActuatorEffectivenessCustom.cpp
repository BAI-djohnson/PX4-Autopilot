/****************************************************************************
 *
 *   Copyright (c) 2021 PX4 Development Team. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name PX4 nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

#include "ActuatorEffectivenessCustom.hpp"

ActuatorEffectivenessCustom::ActuatorEffectivenessCustom(ModuleParams *parent):
	ModuleParams(parent)
{
}

float getScaleParameter(uint8_t n)
{
	// CA_ACTn_SC: scale
	char buffer[17];
	sprintf(buffer, "CA_ACT%u_SC", n);
	param_t param_handle = param_find(buffer);

	if (param_handle == PARAM_INVALID) {
		PX4_ERR("invalid parameter %s", buffer);
		return 0.f;
	}

	float scale = 1.f;

	if (param_get(param_handle, &scale) != PX4_OK) {
		PX4_ERR("param_get %s failed", buffer);
		return 0.f;
	}

	return scale;
}

bool ActuatorEffectivenessCustom::getEffectivenessMatrix(matrix::Matrix<float, NUM_AXES, NUM_ACTUATORS> &matrix_0,
		matrix::Matrix<float, NUM_AXES, NUM_ACTUATORS> &matrix_1, bool force)
{
	// TODO:
	//  - airspeed scaling
	//  - battery scaling
	//  - publish motors and servos (handle ranges)
	//  - disable individual actuators
	//      - feedback from output module (actual failures)
	//      - VTOL transitions (cleanly blend in and out?)
	//      -   eg disable all downward thrust
	//      -   eg disable all control surfaces
	//      -  blend in/out higher level by adjusting max? then completely purge from effectiveness once off
	if ((_updated || force) && hrt_elapsed_time(&_last_effectiveness_update) > 200_ms) {
		_updated = false;

		// int num_actuators = 0;
		_effectiveness_0.zero();
		_effectiveness_1.zero();

		int n_0 = 0; // iterator for matrix 0
		int n_1 = 0; // iterator for matrix 1

		_acutator_index_0 = 0;
		_acutator_index_1 = 0;

		for (int n = 0; n < NUM_ACTUATORS; n++) {
			// CA_ACTn_FUNC: look up function
			char buffer[17];
			sprintf(buffer, "CA_ACT%u_FUNC", n);
			int32_t ctrl_func = 0;
			param_get(param_find(buffer), &ctrl_func);

			switch (ctrl_func) {
			case 0:
				// disabled
				break;

			case 1: {
					_has_MC = true;
					// 1: custom thrust (parameters)
					// matrix::Vector3f axis{0.f,0.f,-1.f}; // default axis
					matrix::Vector3f axis{sinf(_combined_tilt), 0.f, -cosf(_combined_tilt)}; // tilted axis (forward tilt)
					matrix::Vector3f position{};
					float thrust_coef = 0.f;
					float moment_ratio = 0.f;

					for (int i = 0; i < 3; i++) {
						char axis_char = 'X' + i;

						// CA_ACTn_P{X,Y,Z}
						sprintf(buffer, "CA_ACT%u_P%c", n, axis_char);

						if (param_get(param_find(buffer), &position(i)) != PX4_OK) {
							PX4_ERR("unable to get %s", buffer);
						}

						// // CA_ACTn_A_{X,Y,Z}
						// sprintf(buffer, "CA_ACT%u_A%c", n, axis_char);

						// if (param_get(param_find(buffer), &axis(i)) != PX4_OK) {
						// 	PX4_ERR("unable to get %s", buffer);
						// }
					}

					// CA_ACTn_CT TODO
					sprintf(buffer, "CA_ACT%u_CT", n);
					param_get(param_find(buffer), &thrust_coef);

					// CA_ACTn_KM TODO
					sprintf(buffer, "CA_ACT%u_KM", n);
					param_get(param_find(buffer), &moment_ratio);

					// Normalize axis
					float axis_norm = axis.norm();

					if (axis_norm > FLT_EPSILON) {
						axis /= axis_norm;

					} else {
						// Bad axis definition, ignore this rotor
						continue;
					}

					// Get coefficients
					float ct = thrust_coef;
					float km = moment_ratio;

					if (fabsf(ct) < FLT_EPSILON) {
						continue;
					}

					// Compute thrust generated by this rotor
					const matrix::Vector3f thrust{ct * axis};

					// Compute moment generated by this rotor
					const matrix::Vector3f moment{ct * position.cross(axis) - ct *km * axis};

					// Fill corresponding items in effectiveness matrix
					for (size_t j = 0; j < 3; j++) {
						_effectiveness_0(j, n_0) = moment(j);
						_effectiveness_0(j + 3, n_0) = thrust(j);
					}

					_actuator_0_type[_acutator_index_0] = 1;
					n_0++;
					_acutator_index_0++;
				}

				break;

			case 2: {
					// 2: custom torque (parameters)

					// CA_ACTn_TRQ_R
					// CA_ACTn_TRQ_P
					// CA_ACTn_TRQ_Y
					char torque_str[3][17];
					sprintf(torque_str[0], "CA_ACT%u_TRQ_R", n);
					sprintf(torque_str[1], "CA_ACT%u_TRQ_P", n);
					sprintf(torque_str[2], "CA_ACT%u_TRQ_Y", n);

					for (int i = 0; i < 3; i++) {
						// CA_ACTn_TRQ_{R,P,Y}
						param_get(param_find(torque_str[i]), &_effectiveness_0(i, n));
					}
				}
				break;

			case 100: {
					_is_VTOL |= _has_MC;

					// 100: Aileron, scaled (CA_ACTn_SC) roll torque
					if (_is_VTOL) {
						_effectiveness_1(0, n_1) = getScaleParameter(n);
						_actuator_1_type[_acutator_index_1] = 2;
						n_1++;
						_acutator_index_1++;

					} else {
						_effectiveness_0(0, n_0) = getScaleParameter(n);
						_actuator_0_type[_acutator_index_0] = 2;
						n_0++;
						_acutator_index_0++;
					}
				}
				break;

			case 101: {
					_is_VTOL |= _has_MC;

					// 101: Elevator, scaled (CA_ACTn_SC) pitch torque
					if (_is_VTOL) {
						_effectiveness_1(1, n_1) = getScaleParameter(n);
						_actuator_1_type[_acutator_index_1] = 2;
						n_1++;
						_acutator_index_1++;

					} else {
						_effectiveness_0(1, n_0) = getScaleParameter(n);
						_actuator_0_type[_acutator_index_0] = 2;
						n_0++;
						_acutator_index_0++;
					}
				}
				break;

			case 102: {
					_is_VTOL |= _has_MC;

					// 102: Rudder, scaled (CA_ACTn_SC) yaw torque
					if (_is_VTOL) {
						_effectiveness_1(2, n_1) = getScaleParameter(n);
						_actuator_1_type[_acutator_index_1] = 2;
						n_1++;
						_acutator_index_1++;

					} else {
						_effectiveness_0(2, n_0) = getScaleParameter(n);
						_actuator_0_type[_acutator_index_0] = 2;
						n_0++;
						_acutator_index_0++;
					}
				}
				break;

			case 103: {
					_is_VTOL |= _has_MC;

					// 103: Throttle, scaled (CA_ACTn_SC) X thrust
					if (_is_VTOL) {
						_effectiveness_1(3, n_1) = getScaleParameter(n);
						_actuator_1_type[_acutator_index_1] = 1;
						n_1++;
						_acutator_index_1++;

					} else {
						_effectiveness_0(3, n_0) = getScaleParameter(n);
						_actuator_0_type[_acutator_index_0] = 1;
						n_0++;
						_acutator_index_0++;
					}
				}
				break;

			case 104: {
					// 104: Elevon(+), scaled (CA_ACTn_SC) roll & pitch torque
					float scale = getScaleParameter(n);
					_effectiveness_0(0, n) = 0.5f * scale;
					_effectiveness_0(1, n) = 0.5f * scale;
				}
				break;

			case 105: {
					// 105: Elevon(+), scaled (CA_ACTn_SC) -roll & pitch torque
					float scale = getScaleParameter(n);
					_effectiveness_0(0, n) = -0.5f * scale;
					_effectiveness_0(1, n) =  0.5f * scale;
				}
				break;

			case 106: {
					// 106: V-Tail (+), scaled (CA_ACTn_SC) pitch & yaw torque
					float scale = getScaleParameter(n);
					_effectiveness_0(1, n) = 0.5f * scale;
					_effectiveness_0(2, n) = 0.5f * scale;
				}
				break;

			case 107: {
					// 107: V-Tail (-), scaled (CA_ACTn_SC) pitch & -yaw torque
					float scale = getScaleParameter(n);
					_effectiveness_0(1, n) =  0.5f * scale;
					_effectiveness_0(2, n) = -0.5f * scale;
				}
				break;

			case 120: {
					// tilt not used for yaw control (VTOL tiltrotor)
					// do not add to effectiveness but increase counter
					_actuator_0_type[_acutator_index_0] = 3;
					_acutator_index_0++;
				}
				break;

			case 121: {
					// tilt front left (VTOL tiltrotor)
					_effectiveness_0(2, n_0) = getScaleParameter(n);
					n_0++;
					_actuator_0_type[_acutator_index_0] = 4;
					_acutator_index_0++;
				}
				break;


			case 130: {
					// Flaps
					// do not add to effectiveness but increase counter
					_actuator_0_type[_acutator_index_0] = 5;
					_acutator_index_0++;
				}
				break;

			default:
				PX4_ERR("%s invalid function %d", buffer, n);
				break;
			}

			// TODO: change way num_actuator_0/1 is counted
			// if (_effectiveness_0.col(n).longerThan(0.f)) {
			// 	num_actuators = n + 1;
			// }
		}

		_effectiveness_0.transpose().print();
		_effectiveness_1.transpose().print();

		_num_actuators_0 = n_0;
		_num_actuators_1 = n_1;
		matrix_0 = _effectiveness_0;
		matrix_1 = _effectiveness_1;
		_last_effectiveness_update = hrt_absolute_time();
		return true;
	}

	return false;
}

void
ActuatorEffectivenessCustom::setCombinedTilt(float tilt)
{
	// only update tilt if it has changed
	if (abs(tilt - _combined_tilt) > FLT_EPSILON) {
		ActuatorEffectiveness::setCombinedTilt(tilt);
		_updated = true;
	}
}
